

# 一、项目的整合





# 二、素材整理：音乐 和 图片 

描述时可以带着几张图片当例子：boss图片 子弹图片 飞机图片.....

![image-20240625153620650](C:\Users\zxk\AppData\Roaming\Typora\typora-user-images\image-20240625153620650.png)

子弹发射声音，背景音乐，击中敌机音效

# 三、登录界面、注册页面、、、

## 1.LandFrame游戏的登录

1. **登录窗口设置**：
   - 创建了一个标题为 "交通违章管理系统" 的窗口，不允许用户调整大小，设置为不可装饰（无边框），并居中显示。
2. **面板和布局**：
   - 使用 `MPanel` 创建背景面板，并设置网格组布局（`GridBagLayout`）。
3. **用户界面组件**：
   - 包括用户名文本框（`username`）、密码文本框（`passwordField`）、以及用于登录、注册、重置、退出的按钮。
4. **图片资源**：
   - 使用 `getResource` 加载图片资源，并设置按钮的图标和鼠标悬停、按下时的图片。
5. **按钮事件监听器**：
   - 为登录按钮、注册按钮、重置按钮和退出按钮分别添加了事件监听器，以处理用户点击事件。
6. **登录逻辑**：
   - 当用户点击登录按钮时，会从文本框和密码框中获取用户名和密码，然后与后端数据（通过 `Dao.getInstance().sPlayerPassword(user)` 获取）进行比对验证。
7. **用户验证**：
   - 如果用户名或密码错误，会弹出提示框告知用户。
8. **注册新用户**：
   - 如果用户需要注册，可以点击注册按钮打开 `Register` 类创建的注册对话框。
9. **重置密码**：
   - 点击重置按钮会清空用户名和密码输入框。
10. **退出登录窗口**：
    - 点击退出按钮会关闭登录窗口。
11. **主方法 (`main`)**:
    - 设置外观（look and feel）为系统默认，然后创建 `LandFrame` 实例，并将其设置为可见。
12. **登录成功后的操作**：
    - 如果用户名和密码验证成功，会将用户名设置到 `GamePane.name` 和 `MenuPane.plyer`，然后隐藏登录窗口，允许用户进入游戏或管理系统。

## 2.MenuPane

1. **继承 `Panel` 类**：`MenuPane` 继承自 `java.awt.Panel` 类，是一个容器用来放置组件。
2. **静态成员变量**：
   - `plyer` 和 `Password` 用于存储玩家名称和密码，但它们被声明为静态的，这可能不是最佳实践，因为它们的状态应该依赖于具体用户。
3. **按钮组件**：
   - 定义了六个按钮：`startGame`（开始游戏）、`restart`（重新开始）、`conGame`（继续游戏）、`loginGame`（登录游戏）、`sorceList`（资源列表）、`exitGame`（退出游戏）。
4. **状态常量**：
   - 定义了四个状态常量：`CANSTART`（可开始）、`RUNNING`（运行中）、`PAUSE`（暂停）、`GAMEOVER`（游戏结束）。
5. **构造函数**：
   - `MenuPane()` 构造函数用于初始化面板和按钮，并为每个按钮设置了图标和事件监听器。
6. **按钮图标设置**：
   - 使用 `getResource` 方法加载图标图片，并使用 `ImageIcon` 设置按钮的图标。
7. **事件监听器**：
   - 为每个按钮添加了 `ActionListener`，当按钮被点击时执行特定的动作。
8. **开始游戏逻辑**：
   - `startGame` 按钮检查 `GamePane.name` 是否非空，非空则将 `GamePane.state` 设置为 `RUNNING` 并启动游戏。
9. **登录逻辑**：
   - `loginGame` 按钮打开一个新的登录窗口 `LandFrame`。
10. **退出游戏逻辑**：
    - `exitGame` 按钮调用 `System.exit(0)` 来退出游戏和应用程序。
11. **资源列表逻辑**：
    - `sorceList` 按钮打开一个新的对话框 `SorceList`。
12. **继续游戏逻辑**：
    - `conGame` 按钮如果游戏已启动，则将 `GamePane.state` 设置为 `RUNNING`。
13. **面板布局**：
    - 将所有按钮添加到 `MenuPane` 面板中，但具体的布局管理器未在代码中显示。
14. **面板样式**：
    - 为按钮设置了边距、内容填充和边框绘制样式。



## 3.MainFrame

1. **定义常量**：
   - `WIDTH` 和 `HEIGHT` 分别定义了主窗口的宽度和高度。
2. **主方法 (`main`)**:
   - 这是应用程序的入口点，创建了 `GamePane` 和 `MenuPane` 的实例。
3. **创建 `JSplitPane`**:
   - 使用 `JSplitPane.HORIZONTAL_SPLIT` 创建一个水平分割的面板，左侧是 `GamePane`，右侧是 `MenuPane`。
4. **创建 `MainFrame` 实例**:
   - 实例化 `MainFrame` 类，设置窗口大小、位置（居中屏幕）、默认关闭操作（退出应用程序）、添加分割面板，并设置为可见。
5. **窗口属性设置**:
   - `setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);`: 设置窗口关闭时默认执行的操作为退出程序。注意这里的分号可能是多余的。
   - `setResizable(false);`: 设置窗口不允许用户调整大小。
6. **分割面板设置**:
   - `split.setDividerLocation(512);`: 设置分割条的位置在水平方向的512像素处。
   - `split.setEnabled(false);`: 禁用分割条，不允许用户拖动调整两个面板的大小。
7. **启动游戏**:
   - `lgp.startGame();`: 调用 `GamePane` 实例的 `startGame` 方法，这可能会启动游戏循环或初始化游戏状态。
8. **居中显示窗口**:
   - 使用 `Toolkit.getDefaultToolkit().getScreenSize()` 获取屏幕尺寸，并计算窗口位置，使窗口在屏幕上居中显示。

## 4.Register类

1. **设置对话框**：
   - 创建一个模态对话框，设置标题为"用户注册"，并设置对话框的大小和位置。
2. **用户界面组件**：
   - 使用 `JPanel`、`JTextField`、`JPasswordField`、`JButton` 和 `JLabel` 创建用户界面。
3. **输入字段**：
   - 提供了用户名、新密码和重复密码的输入字段。
4. **布局管理**：
   - 使用 `BoxLayout` 来组织对话框中的组件布局。
5. **按钮和事件处理**：
   - 创建确定和退出两个按钮，并为它们添加事件监听器。
6. **注册逻辑**：
   - 当用户点击确定按钮后，会从输入字段中获取数据，检查是否为空，然后验证新密码和重复密码是否一致。
7. **密码显示转换**：
   - `turnCharsToString` 方法用于将 `char` 数组转换成 `String`，这通常用于将密码字段的内容转换为字符串，以便进行进一步处理。
8. **错误处理和用户提示**：
   - 如果输入信息不全或密码不一致，会通过 `JOptionPane` 显示相应的提示信息。
9. **主方法**：
   - `main` 方法设置了外观（look and feel）为系统默认，并创建了 `Register` 对话框实例，然后将其设置为可见。
10. **资源管理**：
    - 注册成功后，通过调用 `dispose()` 方法关闭对话框并释放资源。
11. **Dao类集成**：
    - `Dao` 类用于数据访问，`iPlayer` 方法可能用于将新用户信息存储到数据库。



# 四、数据库模块

这个包下的三个都是为了实现和数据库的连接

用户注册后数据存储就是通过这个包实现的



![image-20240623141620501](C:\Users\27934\AppData\Roaming\Typora\typora-user-images\image-20240623141620501.png)



## BaseDao

1. **数据操作方法**：
   - 提供了多个受保护的（protected）方法来执行不同类型的数据库查询操作。
2. **查询多条记录**：
   - `selectSomeNote(String sql)`：执行SQL查询，返回一个包含多条记录的 `Vector`，每条记录也是一个 `Vector<Object>`。
3. **查询单条记录**：
   - `selectOnlyNote(String sql)`：执行SQL查询，返回一个包含单条记录的 `Vector<Object>`。
4. **查询多个值**：
   - `selectSomeValue(String sql)`：执行SQL查询，返回一个包含多个值的 `Vector<Object>`，通常用于查询某个字段的多个值。
5. **查询单个值**：
   - `selectOnlyValue(String sql)`：执行SQL查询，返回单个值 `Object`。
6. **执行事务性操作**：
   - `longHaul(String sql)`：执行事务性SQL操作，如插入、更新或删除。该方法尝试提交事务，如果发生异常则回滚事务。
7. **数据库连接**：
   - 所有方法都使用 `JDBC.getConnection()` 来获取数据库连接，这里假设 `JDBC` 是一个提供了 `getConnection` 静态方法的工具类，用于数据库连接。
8. **异常处理**：
   - 所有数据库操作都包含在 `try-catch` 块中，以处理 `SQLException`。如果发生异常，会打印堆栈跟踪。
9. **事务管理**：
   - 在 `longHaul` 方法中，通过 `conn.setAutoCommit(false)` 开始事务，并通过 `conn.commit()` 提交事务。如果出现异常，则通过 `conn.rollback()` 回滚事务。
10. **返回结果**：
    - 所有查询方法都返回结果，而 `longHaul` 方法返回一个布尔值，表示事务是否成功执行。

## Dao

1. **单例模式**：
   - `Dao` 类使用静态初始化块和静态方法 `getInstance()` 来确保只有一个 `Dao` 实例被创建。
2. **私有构造函数**：
   - `Dao` 类没有显示的构造函数，这意味着不能直接实例化它，只能通过 `getInstance()` 方法获取实例。
3. **数据库操作方法**：
   - 提供了一系列方法来执行数据库操作，包括查询和更新玩家信息。
4. **查询所有用户信息**：
   - `sScoreList()` 方法返回一个 `Vector`，包含所有玩家的详细信息，按分数降序排列。
5. **查询玩家名称列表**：
   - `sPlyerName()` 方法返回一个 `Vector`，包含所有玩家的名称。
6. **更新玩家分数**：
   - `uScore(String name, int score)` 方法接受玩家名称和分数，构造SQL更新语句，并调用 `longHaul(sql)` 方法执行更新操作。
7. **查询玩家分数**：
   - `sScore(String name)` 方法接受玩家名称，查询并返回该玩家的分数。
8. **查询玩家密码**：
   - `sPlayerPassword(String name)` 方法接受玩家名称，查询并返回该玩家的密码。
9. **增加玩家信息到排行榜**：
   - `iScoreList(String name, int score)` 方法接受玩家名称和分数，构造SQL插入语句，并调用 `longHaul(sql)` 方法将新玩家信息添加到数据库。
10. **增加新玩家**：
    - `iPlayer(String name, String password)` 方法接受玩家名称和密码，构造SQL插入语句，并调用 `longHaul(sql)` 方法将新玩家添加到数据库。
11. **执行事务性操作**：
    - `longHaul(String sql)` 方法在 `BaseDao` 类中定义，用于执行事务性SQL操作，如插入、更新或删除，并处理事务的提交或回滚。

## JDBC

1. **数据库连接配置**：
   - 类中定义了数据库连接所需的参数，包括驱动类名（`DRIVERCLASS`）、数据库URL（`URL`）、用户名（`USERNAME`）和密码（`PASSWORD`）。
2. **静态初始化块**：
   - 用于加载数据库驱动类，这是建立数据库连接的前提。
3. **线程本地存储**：
   - 使用 `ThreadLocal` 来为每个线程提供独立的数据库连接，这有助于避免多线程环境下的连接冲突。
4. **获取数据库连接**：
   - `getConnection()` 方法用于获取数据库连接。如果线程本地存储中没有有效的连接，则会创建一个新的连接。
5. **关闭数据库连接**：
   - `closeConnection()` 方法用于关闭数据库连接，并将其从线程本地存储中移除。
6. **异常处理**：
   - 在加载驱动类和获取连接的过程中，可能会抛出 `SQLException` 和 `ClassNotFoundException` 异常，这些异常被捕捉并打印堆栈跟踪。
7. **连接状态检查**：
   - 在 `closeConnection()` 方法中，通过尝试关闭连接来检查连接是否已经关闭，并返回相应的布尔值。



# 五、飞行物FlyingObject抽象类

## 

1. **成员变量**：
   - `x` 和 `y` 表示飞行对象在屏幕上的位置。
   - `img` 是 `BufferedImage` 类型，代表对象的视觉图像。
   - `height` 和 `width` 定义了对象的尺寸。
   - `life` 表示对象的健康值或生命值。
   - `deepx` 和 `deepy` 分别代表水平和垂直方向上的移动速度。
2. **静态变量**：
   - `xadd`、`yadd` 和 `lifeadd` 是静态变量，用于调整飞行对象的位置和生命值。这些可能用于根据游戏等级或难度来缩放属性。
3. **抽象方法**：
   - `step()`：一个抽象方法，子类必须实现以定义对象在每一帧或游戏循环迭代中的行为。
   - `outofBounds()`：一个抽象方法，子类必须实现以检查对象是否已移出游戏屏幕。
4. **射击逻辑**：
   - `shootBy(Bullet bullet)`：一个方法，用于确定飞行对象是否被子弹击中。它使用轴对齐的边界框碰撞检测。
5. **静态访问器方法**：
   - 提供了获取和设置静态变量 `lifeadd`、`xadd` 和 `yadd` 的方法，允许对所有飞行对象实例的这些属性进行集中控制。
6. **实例访问器方法**：
   - 提供了获取和设置实例变量 `deepx`、`deepy`、`x`、`y`、`life`、`img`、`height` 和 `width` 的方法，以提供封装和数据访问控制。
7. **减少生命值方法**：
   - `subLife()`：一个方法，用于将飞行对象的生命值减少1，可以用于处理碰撞或其他游戏事件中受到的伤害。

# 六、飞行物模块

## **奖励的飞行物类**Bee

1. **成员变量**：
   - `deepx` 和 `deepy` 用于存储蜜蜂的水平和垂直移动速度。
   - `awardType` 表示蜜蜂作为奖励时的类型，用于决定给予玩家什么奖励。
2. **构造函数**：
   - `Bee()` 构造函数初始化蜜蜂的属性，包括生命值、图像、位置、尺寸和移动速度。生命值由静态变量 `lifeadd` 决定，图像设置为 `GamePane.bee`。
3. **随机生成位置和移动方向**：
   - 蜜蜂的 `x` 坐标在屏幕边缘内随机生成，`y` 坐标初始化为屏幕上方（即向下方移动）。
   - `deepx` 的值随机决定向左或向右移动，`deepy` 固定为向下移动。
4. **得分方法**：
   - `getScore()` 方法返回击败蜜蜂所能获得的分数，这里返回的是5分。
5. **移动逻辑**：
   - `step()` 方法用于更新蜜蜂的位置。蜜蜂碰到屏幕边缘时会反向移动，模拟环绕屏幕飞行的行为。
6. **越界检测**：
   - `outofBounds()` 方法检查蜜蜂是否移出了屏幕下方，如果是，则认为它越界。
7. **获取奖励类型**：
   - `getAward()` 方法返回蜜蜂的奖励类型，这可能影响玩家获得的奖励种类。
8. **Award 接口实现**：
   - `Bee` 类实现了 `Award` 接口，这意味着它可能包含一些特殊的奖励逻辑，比如增加生命值或提升火力。

## 小的敌机

1. **得分定义**：
   - `score` 静态常量定义了击败这个敌方飞机所能获得的分数。
2. **构造函数**：
   - `AirPlan()` 构造函数初始化敌方飞机的属性，包括生命值、图像、位置、尺寸和移动速度。生命值由静态变量 `lifeadd` 影响，图像设置为 `GamePane.airplane`。
3. **随机生成位置和移动方向**：
   - 敌方飞机的 `x` 坐标在屏幕边缘内随机生成，`y` 坐标初始化为屏幕上方（即向下方移动）。
   - `deepx` 的值随机决定向左或向右移动，`deepy` 固定为向下移动。
4. **属性访问器**：
   - 提供了 `getDeepx()`、`setDeepx(int deepx)`、`getDeepy()` 和 `setDeepy(int deepy)` 方法，允许外部代码获取和设置 `deepx` 和 `deepy` 的值。
5. **得分方法**：
   - `getScore()` 方法返回击败敌方飞机所能获得的分数，这里返回的是5分。
6. **移动逻辑**：
   - `step()` 方法用于更新敌方飞机的位置。当飞机到达屏幕边缘时会反向移动，模拟环绕屏幕飞行的行为。
7. **越界检测**：
   - `outofBounds()` 方法检查敌方飞机是否移出了屏幕下方，如果是，则认为它越界。
8. **Enemy 接口实现**：
   - `AirPlan` 类实现了 `Enemy` 接口，这意味着它可能包含一些敌方特有的逻辑或属性。

## boss

1. **得分定义**：
   - `score` 静态常量定义了击败这个大型敌方飞机所能获得的分数，此处为10分，区别于其他小型敌人。
2. **成员变量**：
   - `deepy` 变量初始化为2加上一个可能的额外Y轴速度（`yadd`），用于控制飞机的垂直移动速度。
   - `deepx` 变量用于存储飞机的水平移动速度，其值在构造函数中随机确定。
3. **构造函数**：
   - `BigAirPlane()` 构造函数初始化大型敌方飞机的属性，包括生命值、图像、位置、尺寸。生命值由静态变量 `lifeadd` 决定，图像设置为 `GamePane.bigairplane`。
4. **随机生成位置和移动方向**：
   - 敌方飞机的 `x` 和 `y` 坐标在屏幕内随机生成，其中 `y` 坐标初始化为屏幕上方，表示飞机从上向下移动。
5. **属性访问器**：
   - 提供了 `getDeepx()`、`setDeepx(int deepx)`、`getDeepy()` 和 `setDeepy(int deepy)` 方法，允许外部代码获取和设置飞机的移动速度。
6. **得分方法**：
   - `getScore()` 方法重写自 `Enemy` 接口，返回击败大型敌方飞机所能获得的分数，此处为10分。
7. **移动逻辑**：
   - `step()` 方法用于更新大型敌方飞机的位置。当飞机到达屏幕边缘时会反向移动，模拟环绕屏幕飞行的行为。
8. **越界检测**：
   - `outofBounds()` 方法用于检查大型敌方飞机是否移出了屏幕下方，如果是，则认为它越界。
9. **Enemy 接口实现**：
   - `BigAirPlane` 类实现了 `Enemy` 接口，这意味着它可能包含一些敌方特有的逻辑或属性，例如更高的得分或其他特性。



# 七、UI模块

## MTable提供一个具有特定定制行为和外观的表格组件

1. **构造函数**：
   - 提供了两个构造函数，一个是无参数的默认构造函数，另一个接受一个 `DefaultTableModel` 对象作为参数。
2. **默认渲染器设置**：
   - `getDefaultRenderer` 方法重写自 `JTable`，用于设置表格单元格的默认渲染器，并将其水平对齐方式设置为居中。
3. **表头定制**：
   - `getTableHeader` 方法被重写，用于定制表头的行为和外观。表头的列不允许重新排序，表头单元格内容也设置为居中对齐。
4. **单元格编辑**：
   - `isCellEditable` 方法重写，返回 `true` 表示所有单元格都是可编辑的。
5. **行选择**：
   - `setRowSelectionInterval` 方法被重写，提供了两个版本：一个接受开始和结束行的索引来选择多行，另一个接受单个行索引来选择单行。
6. **选择模式**：
   - `getSelectionModel` 方法重写，用于设置表格的选择模式为单选（`ListSelectionModel.SINGLE_SELECTION`）。
7. **继承 `JTable` 的其他行为**：
   - 除了重写的方法外，`MTable` 类还继承了 `JTable` 的所有其他行为和属性。

## MPanel类创建一个带有背景图像的面板

1. **成员变量**：
   - `imageIcon`：用于存储背景图像的 `ImageIcon` 对象。
2. **构造函数**：
   - `MPanel(URL imgUrl)`：接受一个 `URL` 参数，用于指定背景图像的路径。在构造函数中，调用父类的构造函数，设置面板的布局管理器为 `GridBagLayout`，并使用传入的 `URL` 创建 `ImageIcon` 对象。
3. **设置面板大小**：
   - 使用 `setSize` 方法根据 `ImageIcon` 对象的图像宽度和高度设置面板的大小。
4. **重写 `paintComponent` 方法**：
   - `paintComponent(Graphics g)`：重写自 `JPanel` 的方法，用于自定义面板的绘制过程。首先调用超类的 `paintComponent` 方法以保持默认的绘制行为。
   - 在绘制过程中，从 `imageIcon` 获取 `Image` 对象，并使用 `Graphics` 对象的 `drawImage` 方法将背景图像绘制在面板上。
5. **绘制图像**：
   - `drawImage(image, 0, 0, null)`：将图像绘制在面板的 (0,0) 位置，不进行缩放。







# 八、游戏的主要逻辑 GameFrame

1. **静态图像资源**：
   - 定义了一系列 `BufferedImage` 类型的静态成员变量，用于存储游戏中使用的各种图像资源，如英雄、背景、子弹等。
2. **游戏状态和控制**：
   - `state` 静态变量用于跟踪游戏的当前状态（可开始、运行中、暂停、游戏结束）。
3. **构造函数**：
   - `GamePane()` 构造函数用于初始化游戏面板，如果没有提供玩家名称，则可能用于创建一个新的玩家或加载默认设置。
4. **图像资源加载**：
   - 静态初始化块用于加载图像资源，这些资源从类路径下的 `/imgs` 目录中读取。
5. **玩家列表和得分**：
   - `sorceList()` 方法可能用于显示玩家列表或得分
6. **等级逻辑**：
   - `levelAction()` 和 `levelManage()` 方法用于根据玩家的得分调整游戏难度和背景图像。
7. **绘制方法**：
   - `paint()` 方法用于绘制游戏的所有视觉元素，包括背景、分数、英雄、状态和子弹。
8. **游戏循环和计时器**：
   - `timeer()` 方法用于设置游戏循环，使用 `Timer` 和 `TimerTask` 定期更新游戏状态并重绘面板。
9. **游戏逻辑**：
   - `startGame()` 方法初始化游戏逻辑，包括键盘监听器和鼠标监听器，处理玩家输入和游戏循环。
10. **重新开始游戏**：
    - `reatartGame()` 方法用于在游戏结束后重新开始游戏。
11. **敌人进入和处理**：
    - `enterAction()` 和 `nextOne()` 方法用于生成新的敌人并添加到游戏中。
12. **游戏循环的各个部分**：
    - `stepAction()`、`bangAction()`、`hitAction()`、`checkGameOver()` 和 `outOfBoundsAction()` 方法用于执行游戏循环的不同部分，包括更新对象位置、处理碰撞、检查游戏结束条件和移除越界对象。
13. **音频效果**：
    - `bulletMusic()`、`bangMusic()` 和 `musicAction()` 方法用于播放游戏中的音效和背景音乐。
14. **游戏尺寸**：
    - `WIDTH` 和 `HEIGHT` 静态常量定义了游戏面板的宽度和高度。
15. **英雄和敌人**：
    - `Hero` 类用于创建玩家控制的英雄对象，而 `FlyingObject` 类及其子类（如 `AirPlan`、`BigAirPlane` 和 `Bee`）用于创建游戏中的敌人对象。







# 九、子弹

1. **静态成员变量**：
   - `index` 用于跟踪子弹的动画状态或编号，但其具体用途在代码中未明确。
2. **成员变量**：
   - `speed` 表示子弹的垂直速度，数值越大，子弹下落越快。
3. **构造函数**：
   - `Bullet()` 空构造函数，未初始化任何属性。
   - `Bullet(int x, int y)` 带参数的构造函数，初始化子弹的位置、图像、宽度和高度。子弹的图像资源从 `GamePane.bullet` 获取。
4. **移动逻辑**：
   - `step()` 方法用于更新子弹的 `y` 坐标，根据 `speed` 变量调整，使子弹向下移动。
5. **越界检测**：
   - `outofBounds()` 方法检查子弹是否移出了屏幕的上方，如果是，则认为它越界，这通常用于从游戏中移除子弹。
6. **图像资源**：
   - 子弹的图像资源通过 `GamePane.bullet` 静态成员变量获取，这意味着图像资源应在 `GamePane` 类中预先加载。
7. **继承方法**：
   - `step()` 和 `outofBounds()` 方法重写自 `FlyingObject` 类，提供了子弹特定的实现逻辑。

# 十、分数模块

1. **得分GameFrame类**

```
	public void checkGameOver(){
		if(hero.life <= 0){
			state = GAMEOVER;
			int s = (int) Dao.getInstance().sScore(name);
			if(s < score){
			Dao.getInstance().uScore(name, score);
			}
		}
	}
```

2. **获取分数SorceList类**



```
public void getTable(){
		tableValueV.addAll(Dao.getInstance().sScoreList());
		tableModel.setDataVector(tableValueV, tableColumnV);
	}
```

3. **ScoreList**

```



```

1. **设置对话框**：
   - 创建一个模态对话框，设置标题为"资源列表"（乱码可能是由于编码问题），并设置对话框的大小和位置。
2. **用户界面组件**：
   - 使用 `JPanel`、`JTable`、`JScrollPane` 和 `JButton` 创建用户界面。
3. **表格列标题**：
   - `tableColumnV` 定义了表格的列标题，但列标题的文本被乱码替换，需要修正。
4. **表格数据模型**：
   - 使用 `DefaultTableModel` 创建表格的数据模型。
5. **自定义表格**：
   - `MTable` 类可能是 `JTable` 的一个自定义扩展，用于提供特定的表格功能。
6. **初始化表格数据**：
   - `getTable()` 方法用于从后端获取数据并填充表格。
7. **取消按钮**：
   - 创建一个取消按钮，当点击时将关闭对话框。
8. **主方法**：
   - `main` 方法设置了外观（look and feel）为系统默认，并创建了 `SorceList` 对话框实例，然后将其设置为可见。
9. **关闭数据库连接**：
   - `JDBC.closeConnection();` 这行代码可能是为了关闭数据库连接，但由于上下文不清楚，这可能不是必要的。
10. **表格数据获取**：
    - `getTable()` 方法调用 `Dao.getInstance().sScoreList()` 获取数据，这表明可能有一个数据访问对象（DAO）用于数据库操作。
11. **按钮事件监听器**：
    - `CancleButtonActionlistenner` 类实现了 `ActionListener` 接口，当取消按钮被点击时，调用 `dispose()` 方法关闭对话框。
